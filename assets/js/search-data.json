{
  
    
        "post0": {
            "title": "파이썬 4월 11일 강의 복습",
            "content": "numpy . (@,concat,stack,sum,mean,std,max,min,prod,argmax,argmin,cumsum,cumprod,diff) . import numpy as np . &#45336;&#54028;&#51060;&#44277;&#48512; 3&#45800;&#44228; : &#52264;&#50896; . 2차원 배열과 연립 1차 방정식 . - 아래의 연립방정식 고려 . $ begin{cases} y+z+w = 3 x+z+w = 3 x+y+w = 3 x+y+z = 3 end{cases}$ . - 행렬표현? . $ begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1 1 &amp; 0 &amp; 1 &amp; 1 1 &amp; 1 &amp; 0 &amp; 1 1 &amp; 1 &amp; 1 &amp; 0 end{bmatrix} begin{bmatrix} x y z w end{bmatrix} = begin{bmatrix} 3 3 3 3 end{bmatrix}$ . - 풀이 . A=np.array([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]]) A . array([[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) . b=np.array([3,3,3,3]).reshape(4,1) b . array([[3], [3], [3], [3]]) . np.linalg.inv(A)@b . array([[1.], [1.], [1.], [1.]]) . - 다른풀이 b를 아래와 같이 만들어도 된다. . b=np.array([3,3,3,3]) b . array([3, 3, 3, 3]) . b.shape #b.shape은 길이가 1인 튜플로 나옴 . (4,) . np.linalg.inv(A)@b . array([1., 1., 1., 1.]) . @&#51032; &#50976;&#50672;&#49457; . - 엄밀하게는 아래의 행렬곱이 가능 . (2,2) @ (2,1) =&gt; (2,1) | (1,2) @ (2,2) =&gt; (1,2) | . A=np.array([1,2,3,4]).reshape(2,2) b=np.array([1,2]).reshape(2,1) A@b . array([[ 5], [11]]) . A.shape,b.shape,(A@b).shape . ((2, 2), (2, 1), (2, 1)) . A=np.array([1,2,3,4]).reshape(2,2) b=np.array([1,2]).reshape(1,2) b@A . array([[ 7, 10]]) . A.shape, b.shape, (b@A).shape . ((2, 2), (1, 2), (1, 2)) . - 아래는 성립안함 . A=np.array([1,2,3,4]).reshape(2,2) b=np.array([1,2]).reshape(1,2) A@b . ValueError Traceback (most recent call last) Input In [13], in &lt;cell line: 3&gt;() 1 A=np.array([1,2,3,4]).reshape(2,2) 2 b=np.array([1,2]).reshape(1,2) -&gt; 3 A@b ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1 is different from 2) . A=np.array([1,2,3,4]).reshape(2,2) b=np.array([1,2]).reshape(2,1) b@A . ValueError Traceback (most recent call last) Input In [14], in &lt;cell line: 3&gt;() 1 A=np.array([1,2,3,4]).reshape(2,2) 2 b=np.array([1,2]).reshape(2,1) -&gt; 3 b@A ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 2 is different from 1) . - 아래는? $ to$ 모두 계산가능! . (2,) @ (2,2) = (2,) | (2,2) @ (2,) = (2,) | . A=np.array([1,2,3,4]).reshape(2,2) b=np.array([1,2]) A@b . array([ 5, 11]) . A.shape,b.shape,(A@b).shape . ((2, 2), (2,), (2,)) . b를 마치 (2,1)처럼 해석하여 행렬 곱하고 결과는 다시 (2,)로 만든 것 같음. | . b@A . array([ 7, 10]) . A.shape,b.shape,(b@A).shape . ((2, 2), (2,), (2,)) . 여기서는 b를 마치 (1,2)처럼 해석하여 행렬 곱하고 결과는 다시 (2,)로 만든 것 같음. | . b1=np.array([1,2,3,4]) b2=np.array([1,2,3,4]) b1@b2 . 30 . b1.shape,b2.shape,(b1@b2).shape . ((1, 4), (4, 1), (1, 1)) . (1,4) @ (4,1) = (1,1)로 생각 | . - 즉 위는 아래와 같이 해석하고 행렬 곱한 것과 같은 결과 . b1=np.array([1,2,3,4]).reshape(1,4) b2=np.array([1,2,3,4]).reshape(4,1) b1@b2 . array([[30]]) . b1.shape,b2.shape,(b1@b2).shape . ((1, 4), (4, 1), (1, 1)) . - 때로는 (4,1) @ (1,4)와 같은 계산결과를 얻고 싶을 수 있는데 이때는 차원을 명시해야함. . b1=np.array([1,2,3,4]).reshape(4,1) b2=np.array([1,2,3,4]).reshape(1,4) b1@b2 . array([[ 1, 2, 3, 4], [ 2, 4, 6, 8], [ 3, 6, 9, 12], [ 4, 8, 12, 16]]) . &#52264;&#50896; . - 넘파이배열의 차원은 .shape으로 확인가능 . - 아래는 미묘하게 다름 . a=np.array(3.14) #스칼라, 0d array a, a.shape . (array(3.14), ()) . a=np.array([3.14]) #벡터, 1d array a, a.shape . (array([3.14]), (1,)) . a=np.array([[3.14]]) #매트릭스, 2d array a, a.shape . (array([[3.14]]), (1, 1)) . a=np.array([[[3.14]]]) #텐서, 3d array a, a.shape . (array([[[3.14]]]), (1, 1, 1)) . &#45336;&#54028;&#51060;&#44277;&#48512; 4&#45800;&#44228; : &#52629; . np.concatenate . - 기본예제 . a=np.array([1,2]) b=-a . np.concatenate([a,b]) . array([ 1, 2, -1, -2]) . - 응용 . a=np.array([1,2]) b=-a c=np.array([3,4,5]) . np.concatenate([a,b,c]) . array([ 1, 2, -1, -2, 3, 4, 5]) . 여기까지는 concatenate의 메리트가 없어 보임 . | 리스트였다면 a+b+c하면 되는 기능이니깐 . | . - 2d array에 적용 . a=np.arange(4).reshape(2,2) b=-a . np.concatenate([a,b]) . array([[ 0, 1], [ 2, 3], [ 0, -1], [-2, -3]]) . 옆으로 붙이려면? . np.concatenate([a,b],axis=1) . array([[ 0, 1, 0, -1], [ 2, 3, -2, -3]]) . - axis? $ to$ 관찰해보자 . np.concatenate([a,b],axis=0) #np.concatenate([a,b]) 와 완전히 동일한 코드 . array([[ 0, 1], [ 2, 3], [ 0, -1], [-2, -3]]) . np.concatenate([a,b], axis=2) #이런건 없음... . AxisError Traceback (most recent call last) Input In [41], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b], axis=2) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 2 is out of bounds for array of dimension 2 . a=np.array(range(2*3*4)).reshape(2,3,4) a . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) . b=-a b . array([[[ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . np.concatenate([a,b],axis=0) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23]], [[ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . np.concatenate([a,b],axis=1) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23], [-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . np.concatenate([a,b],axis=2) . array([[[ 0, 1, 2, 3, 0, -1, -2, -3], [ 4, 5, 6, 7, -4, -5, -6, -7], [ 8, 9, 10, 11, -8, -9, -10, -11]], [[ 12, 13, 14, 15, -12, -13, -14, -15], [ 16, 17, 18, 19, -16, -17, -18, -19], [ 20, 21, 22, 23, -20, -21, -22, -23]]]) . np.concatenate([a,b],axis=3) . AxisError Traceback (most recent call last) Input In [47], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b],axis=3) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 3 is out of bounds for array of dimension 3 . (분석1) np.concatenate([a,b],axis=0) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape,b.shape,np.concatenate([a,b],axis=0).shape . ((2, 3, 4), (2, 3, 4), (4, 3, 4)) . 첫번째차원이 바뀌었다. =&gt; 첫번째 축이 바뀌었다. =&gt; axis=0 | . (분석2) np.concatenate([a,b],axis=1) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape,b.shape,np.concatenate([a,b],axis=1).shape . ((2, 3, 4), (2, 3, 4), (2, 6, 4)) . 두번째차원이 바뀌었다. =&gt; 두번째 축이 바뀌었다. =&gt; axis=1 | . (분석3) np.concatenate([a,b],axis=2) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape,b.shape,np.concatenate([a,b],axis=2).shape . ((2, 3, 4), (2, 3, 4), (2, 3, 8)) . 세번째차원이 바뀌었다. =&gt; 세번째 축이 바뀌었다. =&gt; axis=2 | . (분석4) np.concatenate([a,b],axis=3) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape,b.shape,np.concatenate([a,b],axis=3).shape . AxisError Traceback (most recent call last) Input In [7], in &lt;cell line: 1&gt;() -&gt; 1 a.shape,b.shape,np.concatenate([a,b],axis=3).shape File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 3 is out of bounds for array of dimension 3 . 네번째차원이 없다. =&gt; 네번째 축이 없다 =&gt; axis=3으로 하면 에러가 난다. | . (추가1) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape,b.shape,np.concatenate([a,b],axis=-1).shape . ((2, 3, 4), (2, 3, 4), (2, 3, 8)) . 마지막 차원이 바뀌었다.=&gt; 마지막 축이 바뀌었다. =&gt; axis=-1 | . (추가2) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . np.concatenate([a,b],axis=-2) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23], [-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . a.shape,b.shape,np.concatenate([a,b],axis=-2).shape . ((2, 3, 4), (2, 3, 4), (2, 6, 4)) . 마지막에서 2번째 차원이 바뀌었다. =&gt; 마지막에서 2번째 축이 바뀌었다. =&gt; axis=-2 | . (보너스3) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . np.concatenate([a,b],axis=-3) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23]], [[ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . a.shape,b.shape,np.concatenate([a,b],axis=-3).shape . ((2, 3, 4), (2, 3, 4), (4, 3, 4)) . 마지막에서 3번째 차원이 바뀌었다. =&gt; 마지막에서 3번째 축이 바뀌었다. =&gt; axis=-3 | . - 0차원은 축이 없으므로 concatenate를 쓸 수 없다. . a=np.array(1) b=np.array(-1) . a.shape,b.shape . ((), ()) . np.concatenate([a,b]) . ValueError Traceback (most recent call last) Input In [20], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b]) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) ValueError: zero-dimensional arrays cannot be concatenated . - 꼭 a,b가 같은 차원일 필요는 없다. . a=np.array(range(4)).reshape(2,2) b=np.array(range(2)).reshape(2,1) . np.concatenate([a,b],axis=1) . array([[0, 1, 0], [2, 3, 1]]) . a.shape,b.shape,np.concatenate([a,b],axis=1).shape . ((2, 2), (2, 1), (2, 3)) . np.stack . ex) (3,) 결합 (3,) =&gt; (3,2) 가 가능할까? | . a=np.array([1,2,3]) b=-a . a,b . (array([1, 2, 3]), array([-1, -2, -3])) . np.concatenate([a,b],axis=1) . AxisError Traceback (most recent call last) Input In [26], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b],axis=1) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 1 is out of bounds for array of dimension 1 . 불가능 | . - 아래와 같이 하면 해결가능 . a=np.array([1,2,3]).reshape(3,1) b=-a . a,b . (array([[1], [2], [3]]), array([[-1], [-2], [-3]])) . np.concatenate([a,b],axis=1) . array([[ 1, -1], [ 2, -2], [ 3, -3]]) . 분석 : (3)(3) =&gt; (3,1)(3,1) =&gt; (3,1) concat (3,1) | . - 위의 과정을 줄여서 아래와 같이 할 수 있음. . a=np.array([1,2,3]) b=-a . np.stack([a,b],axis=1) . array([[ 1, -1], [ 2, -2], [ 3, -3]]) . np.stack([a,b],axis=0) . array([[ 1, 2, 3], [-1, -2, -3]]) . (분석1) . a=np.array([1,2,3]) b=-a . a.shape,b.shape,np.stack([a,b],axis=0).shape . ((3,), (3,), (2, 3)) . (3)(3) =&gt; 첫 위치에 축을 추가 (axis=0) =&gt; (1,3)(1,3) =&gt; (2,3) | . (분석2) . a=np.array([1,2,3]) b=-a . a.shape,b.shape,np.stack([a,b],axis=1).shape . ((3,), (3,), (3, 2)) . (3)(3) =&gt; 두번째 위치에 축을 추가 (axis=1) =&gt; (3,1)(3,1) =&gt; (3,2) | . - 고차원예제 . a=np.arange(3*4*5).reshape(3,4,5) b=-a . a.shape,b.shape . ((3, 4, 5), (3, 4, 5)) . np.stack([a,b],axis=0).shape #(3,4,5) =&gt; (1,3,4,5) // 첫번째 위치에 축이 추가되고 스택 . (2, 3, 4, 5) . np.stack([a,b],axis=1).shape #(3,4,5) =&gt; (3,1,4,5) // 두번째 위치에 축이 추가되고 스택 . (3, 2, 4, 5) . np.stack([a,b],axis=2).shape #(3,4,5) =&gt; (3,4,1,5) // 세번째 위치에 축이 추가되고 스택 . (3, 4, 2, 5) . np.stack([a,b],axis=3).shape #(3,4,5) =&gt; (3,4,5,1) // 네번째 위치에 축이 추가되고 스택 . (3, 4, 5, 2) . np.stack([a,b],axis=-1).shape #axis=-1 &lt;=&gt; axis=3 . (3, 4, 5, 2) . np.stack([a,b],axis=-2).shape #axis=-2 &lt;=&gt; axis=2 . (3, 4, 2, 5) . np.concatenate 는 축의 총 개수를 유지하면서 결합, np.stack 은 축의 갯수를 하나 증가시키면서 결합 . sum . - 1차원 . a=np.array([1,2,3]) a . array([1, 2, 3]) . a.sum() . 6 . a.sum(axis=0) . 6 . -2차원 . a=np.array(range(6)).reshape(2,3) a . array([[0, 1, 2], [3, 4, 5]]) . a.sum() #전체합 . 15 . a.sum(axis=0) . array([3, 5, 7]) . a.sum(axis=1) . array([ 3, 12]) . -2차원 결과 분석 . a.shape,a.sum(axis=0).shape . ((2, 3), (3,)) . 첫번째 축이 삭제됨 =&gt; axis=0 | . a.shape,a.sum(axis=1).shape . ((2, 3), (2,)) . 두번째 축이 삭제됨 =&gt; axis=1 | . - 연습 . a=np.array(range(10)).reshape(5,2) a . array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]) . (문제1) 1열의 합, 2열의 합을 계산 . (풀이) 차원 (5,2) =&gt; (2,)로 나와야 함. 즉 첫번째 축이 삭제되어야 함 . a.sum(axis=0) . array([20, 25]) . (문제2) 1행의 합, 2행의 합... ,5행의 합을 계산 . (풀이) 차원 (5,2) =&gt; (5,)로 나와야 함. 즉 두번째 축이 삭제되어야 함 . a.sum(axis=1) . array([ 1, 5, 9, 13, 17]) . (문제3) a의 모든원소의 합을 계산 . (풀이) 차원이 (5,2) =&gt; ()로 나와야 함. 즉 첫번째 축, 두번째 축 모두 삭제되어야 함 . a.sum() . 45 . a.sum(axis=(0,1)) . 45 . mean,std, max, min, prod . - 모두 sum이랑 유사한 논리 . a=np.array(range(10)).reshape(5,2) a . array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]) . a.mean(axis=0),a.std(axis=0),a.max(axis=0),a.min(axis=0),a.prod(axis=0) . (array([4., 5.]), array([2.82842712, 2.82842712]), array([8, 9]), array([0, 1]), array([ 0, 945])) . a.mean(axis=1),a.std(axis=1),a.max(axis=1),a.min(axis=1),a.prod(axis=1) . (array([0.5, 2.5, 4.5, 6.5, 8.5]), array([0.5, 0.5, 0.5, 0.5, 0.5]), array([1, 3, 5, 7, 9]), array([0, 2, 4, 6, 8]), array([ 0, 6, 20, 42, 72])) . - 참고로 std는 분포를 n으로 나눈다. . a=np.array([1,2,3,4]) a.std() . 1.118033988749895 . np.sqrt(sum((a-a.mean())**2)/4) . 1.118033988749895 . - 분모를 n-1로 나누려면? . a=np.array([1,2,3,4]) a.std(ddof=1) . 1.2909944487358056 . argmax, argmin . - 1차원 . a=np.array([1,-2,3,10,4]) a . array([ 1, -2, 3, 10, 4]) . a.argmax() #가장 큰 값이 위치한 원소의 인덱스를 리턴 . 3 . a.argmin() #가장 작은 값이 위치한 원소의 인덱스를 리턴 . 1 . - 2차원 . np.random.seed(43052) a=np.random.randn(4*5).reshape(4,5) a . array([[ 0.38342049, 1.0841745 , 1.14277825, 0.30789368, 0.23778744], [ 0.35595116, -1.66307542, -1.38277318, -1.92684484, -1.4862163 ], [ 0.00692519, -0.03488725, -0.34357323, 0.70895648, -1.55100608], [ 1.34565583, -0.05654272, -0.83017342, -1.46395159, -0.35459593]]) . a.argmin(), a.min() . (8, -1.9268448358915802) . a.argmax(), a.max() . (15, 1.3456558341738827) . a.argmin(axis=0), a.argmin(axis=1) . (array([2, 1, 1, 1, 2]), array([4, 3, 4, 3])) . a.argmax(axis=0), a.argmax(axis=1) . (array([3, 0, 0, 2, 0]), array([2, 0, 3, 0])) . cumsum,cumprod . - 1차원 . a=np.array([1,2,3,4]) a . array([1, 2, 3, 4]) . a.cumsum() . array([ 1, 3, 6, 10]) . a.cumprod() . array([ 1, 2, 6, 24]) . - 2차원 . a=np.array(range(3*4)).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . a.cumsum(axis=0),a.cumsum(axis=1) . (array([[ 0, 1, 2, 3], [ 4, 6, 8, 10], [12, 15, 18, 21]]), array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38]])) . a.cumprod(axis=0),a.cumprod(axis=1) . (array([[ 0, 1, 2, 3], [ 0, 5, 12, 21], [ 0, 45, 120, 231]]), array([[ 0, 0, 0, 0], [ 4, 20, 120, 840], [ 8, 72, 720, 7920]])) . diff . - 1차차분 . a=np.array([1,2,4,6,7]) a . array([1, 2, 4, 6, 7]) . np.diff(a) . array([1, 2, 2, 1]) . - 2차차분 . np.diff(np.diff(a)) . array([ 1, 0, -1]) . - prepend,append . a=np.array([1,2,4,6,7]) a . array([1, 2, 4, 6, 7]) . np.diff(a,prepend=100) #np.diff(np.array([100]_a.tolist())) . array([-99, 1, 2, 2, 1]) . np.diff(a,append=100) . array([ 1, 2, 2, 1, 93]) . - 2차원 array의 차분 . a=np.arange(24).reshape(4,6) a . array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]]) . np.diff(a,axis=0) . array([[6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6]]) . np.diff(a,axis=1) . array([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) .",
            "url": "https://sjinc.github.io/PyIntro-2022-1/python/2022/07/01/%EA%B0%95%EC%9D%98-%EB%B3%B5%EC%8A%B5.html",
            "relUrl": "/python/2022/07/01/%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8.html",
            "date": " • Jul 1, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://sjinc.github.io/PyIntro-2022-1/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Python 과목 성적 . - A+ . Python 과목 공부 이유 . - AI Engineer가 되기 위해.. . Python 과목 공부를 위한 참고 자료들 . - 전북대학교 통계학과 최규빈 교수님 강의 . - 점프 투 파이썬 https://wikidocs.net/book/1 . - https://jakevdp.github.io/PythonDataScienceHandbook/ . - 효율적 개발로 이끄는 파이썬 실천 기술 . - Learning python : powerful object-oriented programming . - 전문가를 위한 파이썬 : 파이썬3 버전 기준 | 간단하고, 명료하고, 효율적인 파이썬 프로그래밍 | . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://sjinc.github.io/PyIntro-2022-1/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sjinc.github.io/PyIntro-2022-1/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}