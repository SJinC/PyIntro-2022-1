{
  
    
        "post0": {
            "title": "파이썬 4월 13일 강의 복습",
            "content": "numpy . (rand,randn,randint,choice,&#53685;&#44228;&#48516;&#54252;,np.where/np.argwhere,&#51064;&#45937;&#49905;&#44256;&#44553;,np.ix_) . import numpy as np . &#45336;&#54028;&#51060;&#44277;&#48512; 5&#45800;&#44228;: &#47004;&#45924;&#47784;&#46280; . np.random.rand() . - 0~1 사이에서 10개의 난수 생성 . np.random.rand(10) . array([0.40236218, 0.87443506, 0.45839405, 0.59640667, 0.75735355, 0.40706425, 0.0733528 , 0.17604515, 0.86612186, 0.26403677]) . -0~2사이에서 10개의 난수 생성 . np.random.rand(10)*2 . array([1.81799833, 0.41452248, 0.2863462 , 0.82510586, 0.47541581, 1.39861094, 1.68476284, 1.27401562, 0.27471634, 1.19583407]) . - 1~2사이에서 10개의 난수 생성 . np.random.rand(10)+1 . array([1.65355249, 1.54047511, 1.98523073, 1.85773949, 1.58000043, 1.04275226, 1.09609135, 1.38568324, 1.09198105, 1.88517803]) . - 1~3사이에서 10개의 난수 생성 . np.random.rand(10)*2+1 . array([2.11873837, 1.74166251, 2.09131209, 2.98637845, 2.09015142, 2.69748809, 1.25176549, 2.09116953, 2.33496592, 1.65444888]) . np.random.randn() . - N(0,1)에서 10개 추출 . np.random.randn(10) . array([-0.20631419, -0.04131124, 0.72532655, 1.39103001, -0.64461439, 0.56492181, -0.52680442, -0.35162868, -0.09135304, 0.40215028]) . - N(1,1)에서 10개 추출 . np.random.randn(10)+1 . array([ 2.63425535, -0.17660609, -0.49076016, 0.62911989, 1.5310684 , 3.32368726, 1.99533253, 2.00592338, -0.14671444, 0.12775136]) . - N(0,4)에서 10개 추출 (평균이 0이고 분산이 4인 분포) . np.random.randn(10)*2 . array([ 0.12156013, -2.48216171, 1.86544445, -1.21163889, -2.38288207, -2.21207458, 1.0455293 , -0.40744864, 1.47241477, -0.98262694]) . - N(3,4)에서 10개 추출 . np.random.randn(10)*2+3 . array([4.88302298, 2.40360439, 4.4385233 , 5.17978021, 3.64003266, 2.55346388, 2.1418646 , 3.96931924, 6.06363415, 6.0878664 ]) . np.random.randint() . -[0,7)의 범위에서 하나의 정수를 랜덤으로 생성 . np.random.randint(7) . 6 . - [0,7)의 범위에서 20개의 정수를 랜덤으로 생성 . np.random.randint(7,size=(20,)) . array([5, 5, 5, 3, 4, 3, 4, 5, 3, 1, 1, 1, 2, 0, 0, 3, 6, 0, 1, 1]) . -[0,7)의 범위에서 (2,2) shape으로 정수를 랜덤으로 생성 . np.random.randint(7,size=(2,2)) . array([[0, 0], [0, 1]]) . - 위와 같은 코드를 아래와 같이 구현가능 . np.random.randint(low=7,size=(5,5)) . array([[4, 2, 1, 2, 3], [5, 4, 1, 6, 4], [4, 1, 1, 6, 4], [6, 5, 5, 5, 2], [4, 3, 4, 2, 3]]) . -[10,20)의 범위에서 (5,5) shape 정수를 랜덤으로 생성 . np.random.randint(low=10,high=20,size=(5,5)) . array([[10, 11, 14, 13, 16], [10, 15, 18, 18, 18], [13, 19, 16, 12, 18], [10, 11, 14, 19, 14], [18, 13, 15, 14, 16]]) . np.random.choice() . - [0,5) 에서 20개를 뽑음, 중복허용 . np.random.choice(5,20) . array([2, 2, 2, 1, 0, 1, 1, 1, 3, 2, 2, 1, 3, 4, 1, 3, 3, 2, 1, 4]) . np.random.randint(5,size=(20,)) 와 같은 코드 | . - [0,1,2,3]에서 20개를 뽑음, 중복허용 . np.random.choice([0,1,2,3],20) . array([0, 3, 0, 1, 0, 0, 1, 1, 0, 2, 0, 2, 1, 1, 3, 3, 3, 1, 2, 1]) . -[&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;]에서 20개를 뽑음, 중복허용 . np.random.choice([&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;],20) . array([&#39;orange&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;banana&#39;], dtype=&#39;&lt;U6&#39;) . -[&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;]에서 2개를 뽑음, 중복허용 X . np.random.choice([&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;],2,replace=False) . array([&#39;banana&#39;, &#39;orange&#39;], dtype=&#39;&lt;U6&#39;) . &#53685;&#44228;&#48516;&#54252; . np.random.binomial(n=10,p=0.2,size=(5,)) #X1,....,X5 ~ B(10,0.2) . array([2, 1, 0, 1, 2]) . np.random.normal(loc=10,scale=2,size=(5,)) #X1,...,X5 ~N(10,4) . array([ 8.13929528, 7.75328746, 11.09847732, 9.32163608, 11.38410008]) . np.random.randn(5)*2+10 와 같은코드 | . np.random.uniform(low=2,high=4,size=(5,)) #X1,...,X5 ~U(2,4) . array([3.69196416, 3.63529735, 3.58636484, 2.96146708, 2.66701839]) . np.random.rand(5)*2+2 와 같은코드 | . np.random.poisson(lam=5,size=(5,)) #X1,...,X5 ~Poi(5) . array([9, 4, 2, 7, 5]) . &#45336;&#54028;&#51060;&#44277;&#48512; 6&#45800;&#44228;: &#44592;&#53440; &#50976;&#50857;&#54620; &#44592;&#48376;&#44592;&#45733;&#46308; . np.where,np.argwhere . - 1차원 . a=np.array([0,0,0,1,0]) a . array([0, 0, 0, 1, 0]) . np.where(a==1) #조건 a==1을 만족하는 인덱스를 출력하라 . (array([3]),) . np.argwhere(a==1) . array([[3]]) . - 2차원 . np.random.seed(43052) a=np.random.randn(12).reshape(3,4) a . array([[ 0.38342049, 1.0841745 , 1.14277825, 0.30789368], [ 0.23778744, 0.35595116, -1.66307542, -1.38277318], [-1.92684484, -1.4862163 , 0.00692519, -0.03488725]]) . np.where(a&lt;0) # 조건을 만족하는 인덱스가 (1,2),(1,3),(2,0),(2,1),(2,3) 이라는 의미 . (array([1, 1, 2, 2, 2]), array([2, 3, 0, 1, 3])) . np.argwhere(a&lt;0) # 조건을 만족하는 인덱스가 (1,2),(1,3),(2,0),(2,1),(2,3) 이라는 의미 . array([[1, 2], [1, 3], [2, 0], [2, 1], [2, 3]]) . a[np.where(a&lt;0)] #조건을 만족하는 인덱스가 모두 출력 =&gt; 1차원 array로 출력 . array([-1.66307542, -1.38277318, -1.92684484, -1.4862163 , -0.03488725]) . a[np.argwhere(a&lt;0)] #출력 불가능 . IndexError Traceback (most recent call last) Input In [33], in &lt;cell line: 1&gt;() -&gt; 1 a[np.argwhere(a&lt;0)] IndexError: index 3 is out of bounds for axis 0 with size 3 . - np.where의 특수기능 . np.random.seed(43052) a=np.random.randn(12).reshape(3,4) a . array([[ 0.38342049, 1.0841745 , 1.14277825, 0.30789368], [ 0.23778744, 0.35595116, -1.66307542, -1.38277318], [-1.92684484, -1.4862163 , 0.00692519, -0.03488725]]) . np.where(a&lt;0,0,a) #ifelse같은 구문 // a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 a . array([[0.38342049, 1.0841745 , 1.14277825, 0.30789368], [0.23778744, 0.35595116, 0. , 0. ], [0. , 0. , 0.00692519, 0. ]]) . np.where(a&lt;0,0,1) #a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 1 . array([[1, 1, 1, 1], [1, 1, 0, 0], [0, 0, 1, 0]]) . - 요약 . np.where : 인덱스의 좌표를 읽는 가독성은 떨어짐, 그런데 조건에 맞는 원소를 출력하거나 처리하는 (특수기능) 목적으로는 좋은 함수 . | np.argwhere : 인덱스의 좌표를 읽는 가독성은 좋음, 그런데 조건에 맞는 원소를 출력하거나 처리하는 기능은 떨어짐 . | . &#51064;&#45937;&#49905;&#44256;&#44553; . - 원래 a는 2d array . a=np.arange(12).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . - 경우1 : 인덱싱 결과가 1d array로 나올 수 있음 . a[0,:] # 인덱싱의 결과 축의 개수가 바뀜 / 2d array -&gt; 1d array . array([0, 1, 2, 3]) . - 경우2 : 인덱싱 결과가 2d array로 나오게 하기 . a[[0,1],:] # 2d array -&gt; 2d array . array([[0, 1, 2, 3], [4, 5, 6, 7]]) . - 경우1의 상황에서도 축의 개수를 유지하면서 인덱싱하려면? . a[[0],:] . array([[0, 1, 2, 3]]) . a[:,[0]] . array([[0], [4], [8]]) . - 차이를 이해 . a[0,:],a[[0],:] . (array([0, 1, 2, 3]), array([[0, 1, 2, 3]])) . a[:,0],a[:,[0]] . (array([0, 4, 8]), array([[0], [4], [8]])) . np.ix_ . - 인덱싱 비교 . a=np.arange(12).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . a[0:2,0:2] . array([[0, 1], [4, 5]]) . a[[0,1],0:2] . array([[0, 1], [4, 5]]) . a[0:2,[0,1]] . array([[0, 1], [4, 5]]) . 그럼 a[[0,1],[0,1]] 결과 역시 동일 할 것임 . a[[0,1],[0,1]] . array([0, 5]) . 실제로는 [a[0,0],a[1,1]]이 array로 나옴 | . - np.where에서 이미 관찰하였음 . a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . np.where(a%5==0) . (array([0, 1, 2]), array([0, 1, 2])) . a[np.where(a%5==0)] . array([ 0, 5, 10]) . a[[0,1,2],[0,1,2]] . array([ 0, 5, 10]) . - a[[0,1],[0,1]]이 a[0:2,0:2]를 의미하게 하려면 아래와 같이 작성 . a[np.ix_([0,1],[0,1])] . array([[0, 1], [4, 5]]) .",
            "url": "https://sjinc.github.io/PyIntro-2022-1/python/2022/07/02/%EA%B0%95%EC%9D%98%EB%B3%B5%EC%8A%B5.html",
            "relUrl": "/python/2022/07/02/%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8.html",
            "date": " • Jul 2, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "파이썬 3월 23일 강의 복습",
            "content": "&#46357;&#49492;&#45320;&#47532;(&#50672;&#49328;,&#47700;&#49548;&#46300;) , &#46357;&#49492;&#45320;&#47532; &#44256;&#44553;, &#51665;&#54633; (&#49440;&#50616;,&#50896;&#49548;&#52628;&#44032;,&#50896;&#49548;&#49325;&#51228;,&#50672;&#49328;,&#47700;&#49548;&#46300;,for&#47928;) . June 29,2022 | . &#46357;&#49492;&#45320;&#47532; . &#50672;&#49328; . score={&#39;seokjin&#39;:90,&#39;iu&#39;:80} score . {&#39;seokjin&#39;: 90, &#39;iu&#39;: 80} . &#39;seokjin&#39; in score . True . &#39;jk&#39; in score . False . - in은 사실 다른 자료형에서도 가능한 연산임 . (관찰1) . &#39;a&#39; in &#39;seokjin&#39; . False . &#39;j&#39; in &#39;seokjin&#39; . True . (관찰2) . tpl=1,2,3 tpl . (1, 2, 3) . 1 in tpl . True . 5 in tpl . False . (관찰3) . score=[[&#39;seokjin&#39;,90],[&#39;iu&#39;,80],[&#39;jk&#39;,70]] score . [[&#39;seokjin&#39;, 90], [&#39;iu&#39;, 80], [&#39;jk&#39;, 70]] . [&#39;seokjin&#39;,90] in score . True . &#47700;&#49548;&#46300; . (get) . score={&#39;seokjin&#39;:90,&#39;iu&#39;:80} score . {&#39;seokjin&#39;: 90, &#39;iu&#39;: 80} . score.get(&#39;seokjin&#39;) . 90 . score[&#39;seokjin&#39;] #위와 같은 기능 . 90 . 둘 사이의 차이점이 존재 . score[&#39;jk&#39;] #jk가 없어서 key error 발생 . KeyError Traceback (most recent call last) Input In [16], in &lt;cell line: 1&gt;() -&gt; 1 score[&#39;jk&#39;] KeyError: &#39;jk&#39; . score.get(&#39;jk&#39;) #jk가 없으면 아무것도 출력하지 않음 . (keys,values,items) . - .keys() 는 딕셔너리의 키를 리턴 . score={&#39;seokjin&#39;:90,&#39;iu&#39;:80} score . {&#39;seokjin&#39;: 90, &#39;iu&#39;: 80} . _keys=score.keys() _keys #return된 자료형은 우리가 알수 없는 자료형임.. . dict_keys([&#39;seokjin&#39;, &#39;iu&#39;]) . list(_keys) . [&#39;seokjin&#39;, &#39;iu&#39;] . - .values() 는 딕셔너리의 값들을 리턴 . _values=score.values() _values . dict_values([90, 80]) . list(_values) . [90, 80] . - .items()는 딕셔너리의 (키,값)을 리턴. . _items=score.items() _items . dict_items([(&#39;seokjin&#39;, 90), (&#39;iu&#39;, 80)]) . list(_items) . [(&#39;seokjin&#39;, 90), (&#39;iu&#39;, 80)] . - for문에서의 딕셔너리 . for i in score.keys(): print(i) . seokjin iu . for i in score: print(i) . seokjin iu . 딕셔너리 그 자체도 for문에 넣을 수 있음. | i에는 value가 삭제되어 들어감. (즉 key만 들어감) | 결과를 보면 score대신에 score.keys()와 list(score)를 넣었을 때와 결과가 같음. | . list(score) 하면 key만 리턴 . for i in score.values(): print(i) . 90 80 . for k in score.items(): print(k) . (&#39;seokjin&#39;, 90) (&#39;iu&#39;, 80) . for i,j in score.items(): print(i,j) . seokjin 90 iu 80 . for i,j in score.items(): print(i+ &#39;의 중간고사 점수는 %s점 입니다.&#39; %j) . seokjin의 중간고사 점수는 90점 입니다. iu의 중간고사 점수는 80점 입니다. . &#46357;&#49492;&#45320;&#47532; &#44256;&#44553; . key&#45716; &#47928;&#51088;&#50676;&#47564; &#44032;&#45733;&#54620; &#44163;&#51060; &#50500;&#45784;. . - 정수key . score={0:90,1:80,2:70} #key -&gt; 0,1,2 score . {0: 90, 1: 80, 2: 70} . - 인덱싱은? . score[0] . 90 . score[:2] #스트라이딩은 불가능.. . TypeError Traceback (most recent call last) Input In [38], in &lt;cell line: 1&gt;() -&gt; 1 score[:2] TypeError: unhashable type: &#39;slice&#39; . key&#44050;&#51004;&#47196; &#44032;&#45733;&#54620; &#44163;? &#47928;&#51088;&#50676;, &#49707;&#51088;&#44050;, &#53916;&#54540; . score={(&#39;seokjin&#39;,0):20,(&#39;seokjin&#39;,1):80,(&#39;seokjin&#39;,2):90} #0은 출석점수 , 1은 중간점수, 2는 기말 점수 score . {(&#39;seokjin&#39;, 0): 20, (&#39;seokjin&#39;, 1): 80, (&#39;seokjin&#39;, 2): 90} . score[(&#39;seokjin&#39;,0)] . 20 . score[(&#39;seokjin&#39;,3)]=10 #seokjin의 레포트 점수를 추가 . score . {(&#39;seokjin&#39;, 0): 20, (&#39;seokjin&#39;, 1): 80, (&#39;seokjin&#39;, 2): 90, (&#39;seokjin&#39;, 3): 10} . 문자열, 숫자값, 튜플의 공통점? 불변객체 | . &#52280;&#44256; (&#48520;&#48320;&#54805;&#44284; &#44032;&#48320;&#54805;) . (인트형 불변) . a=1 a,id(a) . (1, 140516834601264) . a=2 a,id(a) . (2, 140516834601296) . (문자열 불변) . a=&#39;seokjin&#39; a,id(a) . (&#39;seokjin&#39;, 140516301124528) . a=&#39;Seokjin&#39; a,id(a) . (&#39;Seokjin&#39;, 140516575460080) . (리스트 가변) . a=list(&#39;seokjin&#39;) a,id(a) . ([&#39;s&#39;, &#39;e&#39;, &#39;o&#39;, &#39;k&#39;, &#39;j&#39;, &#39;i&#39;, &#39;n&#39;], 140516434678784) . a[0]=&#39;G&#39; . a,id(a) . ([&#39;G&#39;, &#39;e&#39;, &#39;o&#39;, &#39;k&#39;, &#39;j&#39;, &#39;i&#39;, &#39;n&#39;], 140516434678784) . &#51665;&#54633; . &#49440;&#50616; . a={&#39;notebook&#39;,&#39;desktop&#39;} . &#50896;&#49548;&#52628;&#52636; . 하는 방법 없음 | 하는 의미도 없음 (원소에 접근해서 할 수 있는 게 없음...) | . a={&#39;notebook&#39;,&#39;desktop&#39;} a[0] . TypeError Traceback (most recent call last) Input In [54], in &lt;cell line: 2&gt;() 1 a={&#39;notebook&#39;,&#39;desktop&#39;} -&gt; 2 a[0] TypeError: &#39;set&#39; object is not subscriptable . &#50896;&#49548;&#52628;&#44032; . a={&#39;notebook&#39;,&#39;desktop&#39;} a . {&#39;desktop&#39;, &#39;notebook&#39;} . a.add(&#39;ipad&#39;) a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . a.add(&#39;notebook&#39;) #이미 있는 원소는 추가되지 않음 -&gt; 중복허용하지 않음 a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . &#50896;&#49548;&#49325;&#51228; . a={&#39;desktop&#39;,&#39;ipad&#39;,&#39;notebook&#39;} a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . a.remove(&#39;notebook&#39;) . a . {&#39;desktop&#39;, &#39;ipad&#39;} . &#50672;&#49328; . - in 연산자 . a={&#39;notebook&#39;,&#39;desktop&#39;,&#39;ipad&#39;} a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . &#39;notebook&#39; in a . True . 돌이켜보면 in 연산자는 다른 곳에서도 쓰임 | . - 합집합,교집합,차집합 . day1={&#39;notebook&#39;,&#39;desktop&#39;} day2={&#39;notebook&#39;,&#39;ipad&#39;} . day1 | day2 #합집합 . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . day1 &amp; day2 #교집합 . {&#39;notebook&#39;} . day1-day2 #차집합 . {&#39;desktop&#39;} . day2-day1 #차집합 . {&#39;ipad&#39;} . - 부분집합 . day1={&#39;notebook&#39;,&#39;desktop&#39;} day2=day1|{&#39;ipad&#39;} . day1&lt;day2 #day1는 day2의 부분집합인가? . True . day2&lt;day1 . False . &#47700;&#49548;&#46300; . - 합집합 . day1={&#39;notebook&#39;,&#39;desktop&#39;} day2={&#39;notebook&#39;,&#39;ipad&#39;} . day1.union(day2) . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . day1.intersection(day2) . {&#39;notebook&#39;} . 여러 메소드가 존재함... | . for&#47928; . day1={&#39;notebook&#39;,&#39;desktop&#39;} day2={&#39;notebook&#39;,&#39;ipad&#39;} . for i in day1|day2: print(i) . ipad notebook desktop .",
            "url": "https://sjinc.github.io/PyIntro-2022-1/python/2022/07/02/%EA%B0%95%EC%9D%98-%EB%B3%B5%EC%8A%B5.html",
            "relUrl": "/python/2022/07/02/%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8.html",
            "date": " • Jul 2, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://sjinc.github.io/PyIntro-2022-1/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Python 과목 성적 . - A+ . Python 과목 공부 이유 . - AI Engineer가 되기 위해.. . Python 과목 공부를 위한 참고 자료들 . - 전북대학교 통계학과 최규빈 교수님 강의 . - 점프 투 파이썬 https://wikidocs.net/book/1 . - https://jakevdp.github.io/PythonDataScienceHandbook/ . - 효율적 개발로 이끄는 파이썬 실천 기술 . - Learning python : powerful object-oriented programming . - 전문가를 위한 파이썬 : 파이썬3 버전 기준 | 간단하고, 명료하고, 효율적인 파이썬 프로그래밍 | . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://sjinc.github.io/PyIntro-2022-1/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sjinc.github.io/PyIntro-2022-1/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}